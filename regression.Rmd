---
title: "Regression"
author: "Bryan Chang"
date: "2025-10-10"
output: html_document
---

```{r}
start <- Sys.time()
```

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
```

In this document we perform a statistical test on worm gcamp time series to determine if a response occurs. We fit a linear model $y=\beta_0+\beta_1 t$ and alternative model $y=\beta_0+\beta_1 t+\beta_2 t_++\beta_3 \mathbb{1}(t>0)$ and define our $H_0$ as $\beta_2=0$ and $\beta_3=0$.

I use Jacob's code to load stimulation data.

## Preparing stimulations data

Let's get all the worm indices and then for each worm extract the relevant information about stimulation events:

```{r}
worm_indices <- fs::dir_ls(path = "../exported_data") %>%
  str_subset("stim_neurons.txt") %>% 
  str_extract("(\\d+)_stim", group = 1) %>% 
  as.numeric() %>% 
  sort()
stopifnot(all(worm_indices == seq(0, length(worm_indices)-1)))
stims <- worm_indices %>% 
  map(~ {
    stim_neuron_file <- str_glue("../exported_data/{.x}_stim_neurons.txt")
    labels_file <- str_glue("../exported_data/{.x}_labels.txt")
    vols_file <- str_glue("../exported_data/{.x}_stim_volume_i.txt")
    labels <- readLines(labels_file)
    dat <- tibble(
      vol = as.numeric(readLines(vols_file)) + 1, # convert from 0 indexing
      neuron_indices = as.numeric(readLines(stim_neuron_file))
    ) %>% 
      mutate(
        neuron_indices = if_else(neuron_indices < 0,
                                 neuron_indices,
                                 neuron_indices + 1) # convert from 0 indexing w/o affecting negatives
        )
    dat$neuron <- rep(NA, nrow(dat))
    ii <- dat$neuron_indices
    dat$neuron[ii > 0] <- labels[ii[ii > 0]]
    return(dat)
  })
names(stims) <- worm_indices
```

Let's create a data frame with all stimulation events:

```{r}
stim_events <- stims %>% 
  bind_rows(.id = "worm")
```

Let's see how many stimulation events there are per worm:

```{r}
stim_events %>% 
  filter(neuron_indices > -2) %>% 
  count(worm,sort=TRUE) %>%
  ggplot(aes(x = n)) + 
  geom_histogram() +
  labs(title="How many times is a worm stimulated?",
       subtitle="(neuron_id > -2)")
```

Let's make a feature that records the number of stimulations have occurred prior to the current one for this worm:

```{r}
stim_events <- stim_events %>% 
  group_by(worm) %>% 
  mutate(rank = rank(vol) - 1) %>% 
  ungroup()
```

## Preparing gcamp data

Next, we load the gcamp data for all the worms:

```{r, message=FALSE}
gcamps <- worm_indices %>% map(~ {
  gcamp <- read_delim(str_glue("../exported_data/{.x}_gcamp.txt"),
                      delim = " ", col_names = FALSE)
  times <- readr::read_csv(str_glue("../exported_data/{.x}_t.txt"),
                           col_names = FALSE)[[1]]
  labels <- readLines(str_glue("../exported_data/{.x}_labels.txt"))
  ii_nolabels <- which(labels %in% c("", " "))
  labels[ii_nolabels] <- str_glue("w{.x}_{ii_nolabels}")
  if (ncol(gcamp) != length(labels)) {
    cat(str_glue(
      "Worm {.x} has {length(labels)} labels but {ncol(gcamp)} gcamp columns."
      ), fill=TRUE)
    return(NA)
  }
  gcamp <- as.matrix(gcamp)
  rownames(gcamp) <- times
  colnames(gcamp) <- labels
  gcamp
})
names(gcamps) <- worm_indices
ii_na <- worm_indices %>%
  as.character() %>%
  map_lgl(~ all(is.na(gcamps[[.x]]))) %>% 
  which()
gcamps <- gcamps[-ii_na]
worm_indices <- worm_indices[-ii_na]
stim_events <- stim_events %>% 
  filter(worm %in% worm_indices)

```

Let's look for parts of the recording where linear interpolation appears to have taken place and let's set those to NA.

```{r}
gcamps <- gcamps %>% 
  map(~ {
    is_linear <- abs(apply(.x, 2, diff, differences = 2)) < 1e-5
    is_linear <- rbind(FALSE, is_linear, FALSE) # second diff'ing only for middle pts
    .x[is_linear] <- NA
    return(.x)
  })
```


Now, sometimes the same neuron label appears more than once within a worm.  This is because sometimes a neuron gets split into two spatially separated segments:

```{r}
worm_indices %>%
  as.character() %>%
  map_dfr(~ {
    if (all(is.na(gcamps[[.x]]))) return()
    gcamps[[.x]] %>%
      colnames() %>% 
      table() %>% 
      as_tibble() %>%
      set_names(c("neuron", "n")) %>%
      filter(n > 1) %>% 
      mutate(worm = .x)
    }) %>% 
  arrange(-n)
```

For now let's remove the "merge" and "target" neurons, but we might change our mind once Andy/Sophie look into this more.

Let's average the gcamps for repeated neurons:

```{r}
gcamps <- worm_indices %>%
  as.character() %>%
  map(~ {
    ii_keep <- which(!(colnames(gcamps[[.x]]) %in% c("merge", "target")))
    gcamps[[.x]] <- gcamps[[.x]][, ii_keep]
    repeated <- gcamps[[.x]] %>%
      colnames() %>% 
      table() %>% 
      as_tibble() %>%
      set_names(c("neuron", "n")) %>%
      filter(n > 1) %>% 
      mutate(worm = .x) %>% 
      pull(neuron)
    for (neur in repeated) {
      ii <- which(colnames(gcamps[[.x]]) == neur) # all repeated columns
      gcamps[[.x]][, ii[1]] <- rowMeans(gcamps[[.x]][, ii]) # put avg in first
      gcamps[[.x]] <- gcamps[[.x]][, -ii[-1]] # remove all but first
    }
    return(gcamps[[.x]])
  }) %>% 
  set_names(worm_indices)
```

Let's also remove any neurons that are consistently NaN:

```{r}
gcamps2 <- gcamps %>%
  map(~ {
    ii_keep <- which(colSums(is.na(.x)) < nrow(.x))
    .x[, ii_keep]
  })
```


## Defining whether a response occurred

We need some way to define whether a response occurred. There are many ways to define this. Let's start simple. We will treat this as a one-sided, two-sample test, in which we compare the gcamp in the ~10 seconds before a stimulation to the ~30 seconds after. Let's work this out in an example:

```{r}
#' Plots the gcamp response to a stimulation
#' 
#' Plots the time series of a neuron's gcamp before and after a stimulation.
#' 
#' @param worm_ind The worm index (character)
#' @param vol The volume number of the stimulation
#' @param neuron The neuron label whose response we want to plot
#' @param sec_before The number of seconds before the stimulation to plot
#' @param sec_after The number of seconds after the stimulation to plot
#' 
#' @return A ggplot object
plot_stim_response <- function(worm_ind, vol, neuron, sec_before = 30, sec_after = 30) {
  before <- seq(2 * sec_before)
  after <- 2 * sec_before + seq(2, 2 * sec_after + 1)
  vols <- seq(vol - 2 * sec_before, vol + 2 * sec_after)
  gc <- gcamps[[worm_ind]][vols, neuron]
  tibble(times = seq(-sec_before, sec_after, length = length(vols)), gc = gc) %>%
    ggplot(aes(x = times, y = gc)) + 
    geom_line() +
    geom_point() +
    geom_vline(xintercept = 0) +
    geom_segment(aes(x = -sec_before,
                     xend = -0.5,
                     y = mean(gc[before]),
                     yend = mean(gc[before]))) +
    geom_segment(aes(x = 0.5,
                     xend = sec_after,
                     y = mean(gc[after]),
                     yend = mean(gc[after]))) +
    labs(x = "Time since stimulation (s)",
         y = "raw gcamp",
         title = str_glue("Worm {worm_ind}, neuron {neuron} response to vol {vol}"))
}
```

```{r}
plot_stim_response("0", 102, "w0_1")
```



Let's do a two sample test to see if the mean gcamp is higher after the stimulation than before:

```{r}
w <- stim_events$worm[2]
vol <- stim_events$vol[2]
neuron <- colnames(gcamps[[w]])[1]
sec_before <- 10; sec_after <- 30
before <- seq(2 * sec_before)
after <- 2 * sec_before + seq(2, 2 * sec_after + 1)
vols <- seq(vol - 2 * sec_before, vol + 2 * sec_after)
gc <- gcamps[[w]][vols, neuron]
```

```{r}
t.test(gc[before], gc[after], alternative = "less")
```

This might be ok in this case, but we could also consider a non-parametric test (that doesn't assume normality and can work with small sample sizes):

```{r}
wilcox.test(gc[before], gc[after], alternative = "less")
```
Now let's repeat this for each column of `gcamps[[w]][vols, ]` and get a vector of p-values:

```{r}
pvals <- apply(gcamps[[w]][vols, ], 2, function(x) wilcox.test(x[before],
                                              x[after],
                                              alternative = "less")$p.value)
```

Now let's repeat the above for each worm-vol pair appearing in the `stim_events` data frame:

```{r}
stim_events <- stim_events %>% 
  mutate(pvals = map2(worm, vol, ~ {
    worm_ind <- .x
    vol <- .y
    vols <- seq(vol - 20, vol + 60)
    
    if (all(is.na(gcamps[[worm_ind]]))) {
        cat(str_glue("Worm {worm_ind} is NA."), fill = TRUE)
        return(NA)
    }
    if (max(vols) > nrow(gcamps[[worm_ind]])) {
      cat(str_glue("Skip: Stim in last 30 seconds of recording."),
          fill = TRUE)
      return(NA)
    }
    
    gc <- gcamps[[worm_ind]][vols, ]
    list(apply(gc, 2, function(x) {
      if (any(is.na(x))) return(NA)
      wilcox.test(x[1:20], x[22:81], alternative = "less")$p.value
    }))
  }))
```

```{r}
stim_events1 <- stim_events %>% filter(!is.na(pvals))
pvals <- stim_events1 %>% 
  pull(pvals) %>% 
  map(~ enframe(.x[[1]])) %>% 
  bind_rows(.id = "stim") %>% 
  pivot_wider(id_cols = stim, names_from = name, values_from = value)
```

Let's look at some plots for the smallest p-values:

```{r}
pval_mat <- pvals %>% 
  select(-stim) %>%
  as.matrix()
```

```{r}
imin <- which(pval_mat <= sort(pval_mat)[5], arr.ind = TRUE)
imax <- which(pval_mat >= sort(pval_mat, decreasing = TRUE)[5], arr.ind = TRUE)
```

The biggest responses:

```{r}
for (i in 1:nrow(imin)) {
  g <- plot_stim_response(stim_events1$worm[imin[i, 1]],
                          stim_events1$vol[imin[i, 1]],
                          colnames(pval_mat)[imin[i, 2]])
  print(g)
}
```
All of these are tied with the smallest possible p-value, corresponding to the case where all of the before values are below all of the after values.

```{r}
for (i in 1:nrow(imax)) {
  g <- plot_stim_response(stim_events1$worm[imax[i, 1]],
                          stim_events1$vol[imax[i, 1]],
                          colnames(pval_mat)[imax[i, 2]],
                          sec_before = 20)
  print(g)
}
```

## Linear Spline Model

```{r}
stim_events <- stim_events %>% 
  mutate(pvals_lm_10sb_30sa = map2(worm, vol, ~ {
    worm_ind <- .x
    vol <- .y
    vols <- seq(vol - 20, vol + 60)
    
    if (all(is.na(gcamps[[worm_ind]]))) {
        cat(str_glue("Worm {worm_ind} is NA."), fill = TRUE)
        return(NA)
    }
    if (max(vols) > nrow(gcamps[[worm_ind]])) {
      cat(str_glue("Skip: Stim in last 30 seconds of recording."),
          fill = TRUE)
      return(NA)
    }
    
    gc <- gcamps[[worm_ind]][vols, ]
    
    # Create time vector: -20 to 60 (centered at stimulus)
    time <- seq(-20, 60)
    
    list(apply(gc, 2, function(x) {
      if (any(is.na(x))) return(NA)
      
      # Fit null model: y ~ time
      model_null <- lm(x ~ time)
      
      # Fit alternative model: y ~ time + pmax(time, 0) + I(time > 0)
      model_alt <- lm(x ~ time + pmax(time, 0) + I(time > 0))
      
      # F-test comparing nested models
      f_test <- anova(model_null, model_alt)
      
      # Return p-value
      f_test$`Pr(>F)`[2]
    }))
  }))
```

Adjust for multiple hypothesis testing with Benjamini-Hochberg:

```{r}
stim_events <- stim_events %>%
  mutate(pvals_lm_10sb_30sa_adj = map(pvals_lm_10sb_30sa, ~ {
    if (is.na(.x)) return(NA)
    
    pvals <- .x[[1]]
    pvals_corrected <- p.adjust(pvals, method = "BH")
    list(pvals_corrected)
  }))
```

```{r}
stim_events1 <- stim_events %>% filter(!is.na(pvals_lm_10sb_30sa_adj))
pvals_lm_10sb_30sa_adj <- stim_events1 %>% 
  pull(pvals_lm_10sb_30sa_adj) %>% 
  map(~ enframe(.x[[1]])) %>% 
  bind_rows(.id = "stim") %>% 
  pivot_wider(id_cols = stim, names_from = name, values_from = value)
```

```{r}
pval_mat <- pvals_lm_10sb_30sa_adj %>% 
  select(-stim) %>%
  as.matrix()
```

Look at distribution of p-values.

```{r}
ggplot(data.frame(pval = na.omit(as.vector(pval_mat))), aes(x = pval)) +
  geom_histogram(bins = 50, fill = "lightblue", color = "white") +
  # scale_y_log10() +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "red") +
  labs(title = "Distribution of P-values",
       x = "P-value",
       y = "Count") +
  theme_minimal()
```


Let's filter and plot gcamp data for different p-vals:

```{r}
imin <- which(pval_mat <= sort(pval_mat)[5], arr.ind = TRUE)
imax <- which(pval_mat >= sort(pval_mat, decreasing = TRUE)[5], arr.ind = TRUE)
```

Lowest p-vals:

```{r}
for (i in 1:nrow(imin)) {
  g <- plot_stim_response(stim_events1$worm[imin[i, 1]],
                          stim_events1$vol[imin[i, 1]],
                          colnames(pval_mat)[imin[i, 2]])
  print(g)
}
```

Highest p-vals:

```{r}
for (i in 1:nrow(imax)) {
  g <- plot_stim_response(stim_events1$worm[imax[i, 1]],
                          stim_events1$vol[imax[i, 1]],
                          colnames(pval_mat)[imax[i, 2]],
                          sec_before = 20)
  print(g)
}
```

```{r}
load("gt-table.Rdata")
```

```{r}

# Unnest predictions
predictions <- stim_events %>%
  filter(!is.na(pvals_lm_10sb_30sa_adj)) %>%
  mutate(
    neuron_results = map(pvals_lm_10sb_30sa_adj, ~ {
      pvals <- .x[[1]]
      data.frame(
        recorded_neuron = names(pvals),
        pval_adj = as.numeric(pvals)
      )
    })
  ) %>%
  select(worm, vol, neuron_results) %>%
  unnest(neuron_results) %>%
  filter(!is.na(pval_adj))

# Join with ground truth
eval_data <- predictions %>%
  inner_join(gt_table, by = c("worm", "vol", "recorded_neuron")) %>%
  mutate(
    # Ground truth: TRUE if should reject null (label != 0)
    gt_positive = label != 0
  )

# Evaluate at multiple thresholds
thresholds <- 10^seq(-30, -1)

results <- map_dfr(thresholds, function(thresh) {
  eval_data %>%
    mutate(
      predicted_positive = pval_adj < thresh,
      TP = predicted_positive & gt_positive,
      FP = predicted_positive & !gt_positive,
      TN = !predicted_positive & !gt_positive,
      FN = !predicted_positive & gt_positive
    ) %>%
    summarise(
      threshold = thresh,
      TP = sum(TP),
      FP = sum(FP),
      TN = sum(TN),
      FN = sum(FN),
      .groups = "drop"
    ) %>%
    mutate(
      sensitivity = TP / (TP + FN),  # True Positive Rate / Recall
      specificity = TN / (TN + FP),  # True Negative Rate
      precision = TP / (TP + FP),    # Positive Predictive Value
      accuracy = (TP + TN) / (TP + FP + TN + FN),
      f1_score = 2 * (precision * sensitivity) / (precision + sensitivity)
    )
})

# Visualize performance across thresholds
results %>%
  select(threshold, sensitivity, specificity, precision, accuracy, f1_score) %>%
  pivot_longer(-threshold, names_to = "metric", values_to = "value") %>%
  ggplot(aes(x = threshold, y = value, color = metric)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  scale_x_log10(breaks = thresholds) +
  labs(title = "Performance Metrics vs FDR Threshold",
       x = "FDR Threshold",
       y = "Value",
       color = "Metric") +
  theme_minimal() +
  ylim(0, 1) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

## Using raw data

We saw that many of our highest p-vals were from interpolated data. Let's work with the raw data and exclude time series with $k\ge2$ consecutive NaNs.

```{r}
worm_indices <- fs::dir_ls(path = "../raw_extracted_data") %>%
  str_subset("stim_neurons.txt") %>% 
  str_extract("(\\d+)_stim", group = 1) %>% 
  as.numeric() %>% 
  sort()
stopifnot(all(worm_indices == seq(0, length(worm_indices)-1)))
stims <- worm_indices %>% 
  map(~ {
    stim_neuron_file <- str_glue("../raw_extracted_data/{.x}_stim_neurons.txt")
    labels_file <- str_glue("../raw_extracted_data/{.x}_labels.txt")
    vols_file <- str_glue("../raw_extracted_data/{.x}_stim_volume_i.txt")
    labels <- readLines(labels_file)
    dat <- tibble(
      vol = as.numeric(readLines(vols_file)) + 1, # convert from 0 indexing
      neuron_indices = as.numeric(readLines(stim_neuron_file))
    ) %>% 
      mutate(
        neuron_indices = if_else(neuron_indices < 0,
                                 neuron_indices,
                                 neuron_indices + 1) # convert from 0 indexing w/o affecting negatives
        )
    dat$neuron <- rep(NA, nrow(dat))
    ii <- dat$neuron_indices
    dat$neuron[ii > 0] <- labels[ii[ii > 0]]
    return(dat)
  })
names(stims) <- worm_indices
```

Let's create a data frame with all stimulation events:

```{r}
stim_events <- stims %>% 
  bind_rows(.id = "worm")
```

Let's see how many stimulation events there are per worm:

```{r}
stim_events %>% 
  filter(neuron_indices > -2) %>% 
  count(worm,sort=TRUE) %>%
  ggplot(aes(x = n)) + 
  geom_histogram() +
  labs(title="How many times is a worm stimulated?",
       subtitle="(neuron_id > -2)")
```
Next, we load the gcamp data for all the worms:

```{r, message=FALSE}
gcamps <- worm_indices %>% map(~ {
  gcamp <- read_delim(str_glue("../raw_extracted_data/{.x}_gcamp.txt"),
                      delim = " ", col_names = FALSE)
  times <- readr::read_csv(str_glue("../raw_extracted_data/{.x}_t.txt"),
                           col_names = FALSE)[[1]]
  labels <- readLines(str_glue("../raw_extracted_data/{.x}_labels.txt"))
  ii_nolabels <- which(labels %in% c("", " "))
  labels[ii_nolabels] <- str_glue("w{.x}_{ii_nolabels}")
  if (ncol(gcamp) != length(labels)) {
    cat(str_glue(
      "Worm {.x} has {length(labels)} labels but {ncol(gcamp)} gcamp columns."
      ), fill=TRUE)
    return(NA)
  }
  gcamp <- as.matrix(gcamp)
  rownames(gcamp) <- times
  colnames(gcamp) <- labels
  gcamp
})
names(gcamps) <- worm_indices
# ii_na <- worm_indices %>%
#   as.character() %>%
#   map_lgl(~ all(is.na(gcamps[[.x]]))) %>%
#   which()
# gcamps <- gcamps[-ii_na]
# worm_indices <- worm_indices[-ii_na]
stim_events <- stim_events %>%
  filter(worm %in% worm_indices)

```

```{r}
gcamps <- worm_indices %>%
  as.character() %>%
  map(~ {
    ii_keep <- which(!str_detect(colnames(gcamps[[.x]]), "^merge|^target")) # merge.1 is also merge
    gcamps[[.x]] <- gcamps[[.x]][, ii_keep]
    repeated <- gcamps[[.x]] %>%
      colnames() %>% 
      table() %>% 
      as_tibble() %>%
      set_names(c("neuron", "n")) %>%
      filter(n > 1) %>% 
      mutate(worm = .x) %>% 
      pull(neuron)
    for (neur in repeated) {
      ii <- which(colnames(gcamps[[.x]]) == neur) # all repeated columns
      gcamps[[.x]][, ii[1]] <- rowMeans(gcamps[[.x]][, ii]) # put avg in first
      gcamps[[.x]] <- gcamps[[.x]][, -ii[-1]] # remove all but first
    }
    return(gcamps[[.x]])
  }) %>% 
  set_names(worm_indices)
```

```{r}
library(zoo)

# Efficient rolling quantile approach
remove_outliers_local_quantile <- function(gcamp_matrix, window_size = 50, lower_q = 0.01, upper_q = 0.99) {
  # For each column (neuron)
  for (j in seq_len(ncol(gcamp_matrix))) {
    vals <- gcamp_matrix[, j]
    
    # Calculate rolling lower and upper bounds
    roll_lower <- rollapply(vals, width = 2 * window_size + 1, 
                            FUN = function(x) quantile(x, lower_q, na.rm = TRUE),
                            fill = NA, align = "center", partial = TRUE)
    roll_upper <- rollapply(vals, width = 2 * window_size + 1,
                            FUN = function(x) quantile(x, upper_q, na.rm = TRUE),
                            fill = NA, align = "center", partial = TRUE)
    
    # Vectorized comparison
    gcamp_matrix[vals < roll_lower | vals > roll_upper, j] <- NA
  }
  return(gcamp_matrix)
}
```

```{r}
# Needs refining
# gcamps <- gcamps %>%
#   map(~ remove_outliers_local_quantile(.x, window_size = 5))
```



## Linear Spline Model
We now exclude data that is interpolated over more than k_threshold steps, e.g. there are k_threshold or more consecutive NaNs in the window we are observing.
```{r}
# stim_events <- stim_events %>%
#   mutate(pvals_lm_10sb_30sa = map2(worm, vol, ~ {
#     worm_ind <- .x
#     vol <- .y
#     vols <- seq(vol - 20, vol + 60)
# 
#     if (all(is.na(gcamps[[worm_ind]]))) {
#         cat(str_glue("Worm {worm_ind} is NA."), fill = TRUE)
#         return(NA)
#     }
#     if (max(vols) > nrow(gcamps[[worm_ind]])) {
#       cat(str_glue("Skip: Stim in last 30 seconds of recording."),
#           fill = TRUE)
#       return(NA)
#     }
# 
#     gc <- gcamps[[worm_ind]][vols, ]
# 
#     # Create time vector: -20 to 60 (centered at stimulus)
#     time <- seq(-20, 60)
# 
#     list(apply(gc, 2, function(x) {
# 
#       # Exclude if it has ≥ k consecutive NAs
#       k_threshold = 2
#       rle_na <- rle(is.na(x))
#       if (any(rle_na$values & rle_na$lengths >= k_threshold)) {
#         return(NA)
#       }
# 
#       # Fit null model: y ~ time
#       model_null <- lm(x ~ time)
# 
#       # Fit alternative model: y ~ time + pmax(time, 0) + I(time > 0)
#       model_alt <- lm(x ~ time + pmax(time, 0) + I(time > 0))
# 
#       # F-test comparing nested models
#       f_test <- anova(model_null, model_alt)
# 
#       # Return p-value
#       f_test$`Pr(>F)`[2]
#     }))
#   }))

stim_events1 <- stim_events1 %>%
  mutate(pvals_lm_10sb_10sa = map2(worm, vol, ~ {
    worm_ind <- .x
    vol <- .y
    vols <- seq(vol - 20, vol + 20)

    if (all(is.na(gcamps[[worm_ind]]))) {
        cat(str_glue("Worm {worm_ind} is NA."), fill = TRUE)
        return(NA)
    }
    if (max(vols) > nrow(gcamps[[worm_ind]])) {
      cat(str_glue("Skip: Stim in last 30 seconds of recording."),
          fill = TRUE)
      return(NA)
    }

    gc <- gcamps[[worm_ind]][vols, ]

    # Create time vector: -20 to 20 (centered at stimulus)
    time <- seq(-20, 20)

    list(apply(gc, 2, function(x) {

      # Exclude if it has ≥ k consecutive NAs
      k_threshold = 2
      rle_na <- rle(is.na(x))
      if (any(rle_na$values & rle_na$lengths >= k_threshold)) {
        return(NA)
      }

      # Fit null model: y ~ time
      model_null <- lm(x ~ time)

      # Fit alternative model: y ~ time + pmax(time, 0) + I(time > 0)
      model_alt <- lm(x ~ time + pmax(time, 0) + I(time > 0))

      # F-test comparing nested models
      f_test <- anova(model_null, model_alt)

      # Return p-value
      f_test$`Pr(>F)`[2]
    }))
  }))
```
Adjust for multiple hypothesis testing with Benjamini-Hochberg:

```{r}
# Unnest p-values and keep track of stim and position
# pvals_long <- stim_events %>%
#   mutate(stim = row_number()) %>%
#   filter(!is.na(pvals_lm_10sb_30sa)) %>%
#   select(stim, pvals_lm_10sb_30sa) %>%
#   mutate(pval_list = map(pvals_lm_10sb_30sa, ~ .x[[1]])) %>%
#   unnest(pval_list) %>%
#   group_by(stim) %>%
#   mutate(position = row_number()) %>%
#   ungroup()

library(tidyverse)
pvals_long <- stim_events1 %>%
  mutate(stim = row_number()) %>%
  filter(!is.na(pvals_lm_10sb_10sa)) %>%
  select(stim, pvals_lm_10sb_10sa) %>%
  mutate(pval_list = map(pvals_lm_10sb_10sa, ~ .x[[1]])) %>%
  unnest(pval_list) %>%
  group_by(stim) %>%
  mutate(position = row_number()) %>%
  ungroup()

pvals_long <- pvals_long %>%
  mutate(pval_adj = p.adjust(pval_list, method = "BY"))
```

```{r}
# Now pivot to wide form like your original pvals_lm_10sb_30sa_adj
pvals_wide <- pvals_long %>%
  select(stim, position, pval_adj) %>%
  pivot_wider(names_from = position, values_from = pval_adj)
pval_mat <- pvals_wide %>%
  select(-stim) %>%
  as.matrix()
```

Look at distribution of p-values.

```{r}
ggplot(data.frame(pval = na.omit(as.vector(pval_mat))), aes(x = pval)) +
  geom_histogram(bins = 50, fill = "lightblue", color = "white") +
  # scale_y_log10() +
  geom_vline(xintercept = 0.05, linetype = "dashed", color = "red") +
  labs(title = "Distribution of P-values",
       x = "P-value",
       y = "Count") +
  theme_minimal()
```

Let's filter and plot gcamp data for different p-vals:

```{r}
set.seed(123)  # for reproducibility

p_thresh <- 0.0001

# Indices of p-values below the threshold
imin <- which(pval_mat <= p_thresh, arr.ind = TRUE)

# Indices of p-values above the threshold
imax <- which(pval_mat > p_thresh, arr.ind = TRUE)

# Randomly sample from each group
# For example, sample 5 indices from each side (or fewer if not enough available)
n_samples <- 120

imin_sample <- imin[sample(seq_len(nrow(imin)), 
                           size = min(n_samples, nrow(imin)), 
                           replace = FALSE), , drop = FALSE]

imax_sample <- imax[sample(seq_len(nrow(imax)), 
                           size = min(n_samples, nrow(imax)), 
                           replace = FALSE), , drop = FALSE]
```

Lowest p-vals:

```{r warning=FALSE}
for (i in 1:nrow(imin_sample)) {
  g <- try(
    plot_stim_response(
      stim_events1$worm[imin_sample[i, 1]],
      stim_events1$vol[imin_sample[i, 1]],
      as.numeric(colnames(pval_mat)[imin_sample[i, 2]]),
      sec_before = 20,
      sec_before_fit = 10,
      sec_after_fit = 30,
      use_lm = TRUE
    ),
    silent = TRUE
  )
  
  # Only print if it succeeded
  if (!inherits(g, "try-error")) {
    print(g)
  } else {
    message("Error at i = ", i, " — skipping.")
  }
}
```

Highest p-vals:

```{r warning=FALSE}
for (i in 1:nrow(imax_sample)) {
  g <- try(
    plot_stim_response(
      stim_events1$worm[imax_sample[i, 1]],
      stim_events1$vol[imax_sample[i, 1]],
      as.numeric(colnames(pval_mat)[imax_sample[i, 2]]),
      sec_before = 20,
      use_lm = TRUE,
      sec_before_fit = 10,
      sec_after_fit = 30
    ),
    silent = TRUE
  )
  
  # Only print if it succeeded
  if (!inherits(g, "try-error")) {
    print(g)
  } else {
    message("Error at i = ", i, " — skipping.")
  }
}
```

```{r}
load("gt-table.Rdata")
```

```{r}
# Make sure stim IDs align between pvals_wide and stim_events1
stim_events1$pvals_lm_10sb_10sa_adj <- pval_mat %>%
  split(seq(nrow(.))) %>%     # split matrix rows into list of numeric vectors
  map(~ list(.x))   
```


```{r}

# Unnest predictions
predictions <- stim_events1 %>%
  filter(!is.na(pvals_lm_10sb_10sa_adj)) %>%
  mutate(
    neuron_results = map(pvals_lm_10sb_10sa_adj, ~ {
      pvals <- .x[[1]]
      data.frame(
        recorded_neuron = names(pvals),
        pval_adj = as.numeric(pvals)
      )
    })
  ) %>%
  select(worm, vol, neuron_results) %>%
  unnest(neuron_results) %>%
  filter(!is.na(pval_adj))

# Join with ground truth
eval_data <- predictions %>%
  inner_join(gt_table, by = c("worm", "vol", "recorded_neuron")) %>%
  mutate(
    # Ground truth: TRUE if should reject null (label != 0)
    gt_positive = label != 0
  )

# Evaluate at multiple thresholds
thresholds <- c(.00001, .0001, .001, .01, .05, .1, .15, .2, .25)

results <- map_dfr(thresholds, function(thresh) {
  eval_data %>%
    mutate(
      predicted_positive = pval_adj < thresh,
      TP = predicted_positive & gt_positive,
      FP = predicted_positive & !gt_positive,
      TN = !predicted_positive & !gt_positive,
      FN = !predicted_positive & gt_positive
    ) %>%
    summarise(
      threshold = thresh,
      TP = sum(TP),
      FP = sum(FP),
      TN = sum(TN),
      FN = sum(FN),
      .groups = "drop"
    ) %>%
    mutate(
      sensitivity = TP / (TP + FN),  # True Positive Rate / Recall
      specificity = TN / (TN + FP),  # True Negative Rate
      precision = TP / (TP + FP),    # Positive Predictive Value
      accuracy = (TP + TN) / (TP + FP + TN + FN),
      f1_score = 2 * (precision * sensitivity) / (precision + sensitivity)
    )
})

# Visualize performance across thresholds
results %>%
  select(threshold, sensitivity, specificity, precision, accuracy, f1_score) %>%
  pivot_longer(-threshold, names_to = "metric", values_to = "value") %>%
  ggplot(aes(x = threshold, y = value, color = metric)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  scale_x_log10(breaks = thresholds) +
  labs(title = "Performance Metrics vs FDR Threshold",
       x = "FDR Threshold",
       y = "Value",
       color = "Metric") +
  theme_minimal() +
  ylim(0, 1) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

ROC
```{r}
library(pROC)

roc_obj <- roc(eval_data$gt_positive, 1 - eval_data$pval_adj)  # invert pvals so higher = more likely positive

# Plot ROC
plot(roc_obj, col = "#2c7bb6", lwd = 2, main = "ROC, 10s, 30s")
# abline(a = 0, b = 1, lty = 2, col = "gray")

# Add AUC
auc_value <- auc(roc_obj)
legend("bottomright", legend = paste("AUC =", round(auc_value, 3)), bty = "n")
```



## Eval




```{r}
imin <- which(pval_mat <= sort(pval_mat)[100], arr.ind = TRUE)
imax <- which(pval_mat >= sort(pval_mat, decreasing = TRUE)[100], arr.ind = TRUE)
```

Lowest p-vals:

```{r warning=FALSE}
for (i in 1:nrow(imin)) {
  g <- plot_stim_response(stim_events1$worm[imin[i, 1]],
                          stim_events1$vol[imin[i, 1]],
                          as.numeric(colnames(pval_mat)[imin[i, 2]]), sec_before = 20)
  print(g)
}
```
worm 34, neuron w34_51 response to vol 3305
worm 10, neuron urx response to vol 2764
worm 90, neuron ribl response to vol 1705
worm 12, neuron avel response to vol 1298


Highest p-vals:

```{r warning=FALSE}
for (i in 1:nrow(imax)) {
  g <- plot_stim_response(stim_events1$worm[imax[i, 1]],
                          stim_events1$vol[imax[i, 1]],
                          as.numeric(colnames(pval_mat)[imin[i, 2]]),
                          sec_before = 20)
  print(g)
}
```


p-vals close to target:
```{r warning=FALSE}
target_p <- 0.00001     # The p-value you want to center around
n_to_plot <- 20      # How many responses to plot

# Compute absolute distance from the target p-value
dist_from_target <- abs(pval_mat - target_p)

# Find indices of the n smallest distances
imin <- which(dist_from_target <= sort(dist_from_target)[n_to_plot], arr.ind = TRUE)

# Plot each
for (i in seq_len(nrow(imin))) {
  g <- plot_stim_response(
    stim_events1$worm[imin[i, 1]],
    stim_events1$vol[imin[i, 1]],
    as.numeric(colnames(pval_mat)[imin[i, 2]]),
    sec_before = 10
  )
  print(g)
}
```
# Update plotting

```{r}
#' Plots the gcamp response to a stimulation
#' 
#' Plots the time series of a neuron's gcamp before and after a stimulation.
#' 
#' @param worm_ind The worm index (character)
#' @param vol The volume number of the stimulation
#' @param neuron The neuron label whose response we want to plot
#' @param sec_before The number of seconds before the stimulation to plot
#' @param sec_after The number of seconds after the stimulation to plot
#' @param use_lm Logical. If TRUE, fits an interrupted time series model. If FALSE, plots means.
#' @param sec_before_fit The number of seconds before the stimulation to use for fitting (defaults to sec_before)
#' @param sec_after_fit The number of seconds after the stimulation to use for fitting (defaults to sec_after)
#' 
#' @return A ggplot object
plot_stim_response <- function(worm_ind, vol, neuron, sec_before = 30, sec_after = 30, 
                                use_lm = FALSE, sec_before_fit = NULL, sec_after_fit = NULL) {
  # Set default fitting windows to match plotting windows
  if (is.null(sec_before_fit)) sec_before_fit <- sec_before
  if (is.null(sec_after_fit)) sec_after_fit <- sec_after
  
  before <- seq(2 * sec_before)
  after <- 2 * sec_before + seq(2, 2 * sec_after + 1)
  vols <- seq(vol - 2 * sec_before, vol + 2 * sec_after)
  gc <- gcamps[[worm_ind]][vols, neuron]
  times <- seq(-sec_before, sec_after, length = length(vols))
  
  df <- tibble(times = times, gc = gc)
  
  # Fit model if requested
  if (use_lm) {
    # Subset data for fitting based on sec_before_fit and sec_after_fit
    df_fit <- df %>% filter(times >= -sec_before_fit & times <= sec_after_fit)
    fit <- lm(gc ~ times + pmax(times, 0) + I(times > 0), data = df_fit)
    # Predict for the full plotting window
    df$fitted <- predict(fit, newdata = df)
  }
  
  p <- ggplot(df, aes(x = times, y = gc)) + 
    geom_line() +
    geom_point() +
    geom_vline(xintercept = 0) +
    labs(x = "Time since stimulation (s)",
         y = "raw gcamp",
         title = str_glue("Worm {worm_ind}, neuron {neuron} response to vol {vol}"))
  
  if (use_lm) {
    # Add fitted line
    p <- p + 
      geom_line(aes(y = fitted), color = "blue", linewidth = 1)
  } else {
    # Add mean segments (original behavior)
    p <- p +
      geom_segment(aes(x = -sec_before,
                       xend = -0.5,
                       y = mean(gc[before]),
                       yend = mean(gc[before]))) +
      geom_segment(aes(x = 0.5,
                       xend = sec_after,
                       y = mean(gc[after]),
                       yend = mean(gc[after])))
  }
  
  p
}
```

```{r warning=FALSE}
for (i in 1:nrow(imin)) {
  g <- plot_stim_response(stim_events1$worm[imin[i, 1]],
                          stim_events1$vol[imin[i, 1]],
                          as.numeric(colnames(pval_mat)[imin[i, 2]]),
                          sec_before = 20,
                          use_lm = TRUE,
                          sec_before_fit = 10,
                          sec_after_fit = 10)
  print(g)
}
```

```{r}
plot_stim_response(
      "102", 1659, 37,
      sec_before = 20,
      sec_before_fit = 10,
      sec_after_fit = 10,
      use_lm = TRUE
    )
```
```{r}
stim_events1$worm[27]
```

```{r}
dim(pvals_long)
```

